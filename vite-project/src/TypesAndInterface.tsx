import React from 'react'

// таким образом используя тайпскрипт, создавая переменные мы сразу прописываем тип данных >>> let pizza: string = 'salami';
// чтобы типизировать объект, нужно прописать только те свойства, которые используются в нашем конкретном объекте.

// Теперь давайте посмотрим на слово Type, который мы использовали чтобы описать объект. Если мы хотим создать описание какого-то объекта в TS, и потом его 
// переиспользовать, то у нас есть два варианта. Первое, это использовать слово type
// type Order = {
//     title: string,
//     quantity?: number, 
// }

// И тоже самое мы можем сделать с помощью interface

// interface MyOrder {
//     title: string,
//     quantity?: number
// }

// Граница между этими способами достаточно размыта. И в некоторых ситуациях можно использовать и то и другое. Но есть подход, когда interface используется для описания интерфейсов, а тип используется для описания типов. Что это значит? Это значит, что интерфейс это описание структуры данных в наших например компонентах, например которые мы передаем через пропсы. А type используется для базовых внутренних сущностей, которыми оперирует уже все приложение, которые встречаются во всех компонентах. Например, если наше приложение продает пиццы, то каждую пиццу будем описывать с помощью type, а уже внутри компонентов для описания пропсов будет использовать интерфейсы, грубо говоря так.

// Давайте для лучше понимания посмотрим несколько примеров с типами и интерфейсами. Давайте создадим два типа с помощью type

// type X = {
//     a: string,
//     b: number
// }

// type Y = {
//     c: string,
//     d: number
// }

// И теоретически мы можем расширить наш тип Y свойствами из типа X, чтобы это сделать мы можем сказать

// type Y = X & {
//     c: string,
//     d: number
// }

// Таким образом тип Y содержит не только свойства c и d, но и свойства a и b из типа X. То есть мы расширили наш тип Y. Давайте это протестируем.
// let y: Y = {
//     c: 'test',
//     d: 5
// } и мы сразу видим ошибку, нам нужно дополнить объект свойствами a и b

// точно также мы можем расширять наши интерфейсы, предположим у нас есть интерфейс Auto

// interface Auto {
//     country: string,
// }

// interface BMW {
//     model: string,
//     year: number
// } Соответственно мы можем расширить наш интерфейс BMW свойствами из интерфейса Auto для этого мы применяем extends

// interface BMW extends Auto {
//     model: string,
//     year: number
// }

// const bmw: BMW = {
//     model: '5',
//     year: 2023
// } мы опять же получаем ошибку, у нас не хватает свойств из типа Auto. Если мы добавим сюда свойство country, то наша ошибка пропадает.

// теоретически мы можем расширять наши интерфейсы свойствами из типов и наоборот.

// type X = {
//     a: string,
//     b: number
// }

// interface BMW extends X {
//     model: string,
//     year: number
// } то есть мы наш тип BMW расширили свойствами из типа X
// И соответственно можем сделать наоборот, у нас есть интерфейс BMW

// interface BMW {
//     model: string,
//     year: number
// }

// type X = BMW & {
//     a: string,
//     b: number
// } то есть сейчас мы наши тип X расширили свойствами из нашего интерфейса BMW

export const TypesAndInterface = () => {


    return (
        <div>TypesAndInterface</div>
    )
}
